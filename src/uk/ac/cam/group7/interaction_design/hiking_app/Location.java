package uk.ac.cam.group7.interaction_design.hiking_app;

import org.bitpipeline.lib.owm.WeatherData;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.PriorityQueue;

/**
 * Holds information about the location
 *  2 doubles for Lat and Long (final)
 *  String for name (possibly NULL)
 *  boolean for favourite
 *  Warnings container for all warnings
 *  @author dobrik
 */
public class Location {
    private final float latitude, longitude;
    private String name;
    private boolean isFavourite;
    private final Path path;
    private WarningsContainer warnings;

    private final static String pSep = File.pathSeparator;

    /**
     * Constructor that takes no name parameter
     * and makes a new Location class with these coordinates
     * @param latitude
     * Latitude of location
     * @param longitude
     * Longitude of location
     */
    public Location(float latitude, float longitude) {
        this.latitude = latitude;
        this.longitude = longitude;
        this.name = latitude + ", " + longitude;
        this.isFavourite = false;
        this.path = Paths.get("data" + pSep + generateFileName());
        this.warnings = new WarningsContainer();
    }

    private int generateFileName() {
        int result;
        long temp;
        temp = Double.doubleToLongBits(latitude);
        result = (int) (temp ^ (temp >>> 32));
        temp = Double.doubleToLongBits(longitude);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        return result;
    }

    /**
     * Constructor that takes no name parameter
     * and makes a new Location class with these coordinates
     * @param latitude
     * Latitude of location
     * @param longitude
     * Longitude of location
     * @param isFavourite
     * If location is a favourite
     * @param path
     * The path to the JSON file storing the raw forecast data
     */
    public Location(float latitude, float longitude, boolean isFavourite, Path path, String name,
                    WarningsContainer warnings) {
        this.latitude = latitude;
        this.longitude = longitude;
        this.name = name;
        this.isFavourite = isFavourite;
        this.path = path;
        this.warnings = warnings;
    }

    /**
     * Getter for latitude
     * @return
     * latitude (double)
     */
    public float getLatitude(){
        return latitude;
    }

    /**
     * Getter for longitude
     * @return
     * longitude (double)
     */
    public float getLongitude(){
        return longitude;
    }

    /**
     * Getter for name
     * @return
     * Name of location
     */
    public String getName() {
        return name;
    }

    /**
     * Getter for favourite
     * @return
     * boolean for isFavourite or not
     */
    public boolean isFavourite() {
        return isFavourite;
    }

    /**
     * Setter for the name of the location
     * @param name
     * Name of the location
     */
    public void setName(String name){this.name = name;}

    /**
     * Set favourite location
     * boolean (false:notFav, true:Fav)
     */
    public void toggleFavourite() {
        isFavourite = !isFavourite;
    }

    public Path getPath() {
        return path;
    }

    public WarningsContainer getAllWarnings() {
        return warnings;
    }

    public void addWarning(Warning warning, int severity) {
        warnings.addWarning(warning, severity);
    }

    public Warning getTopWarning() {
        return warnings.getNextWarning();
    }

    public void acknowledgeWarning() {
        warnings.acknowledgeWarning();
    }

    /**
     * Autogenerated method for equals
     * @param o
     * Object to compare to
     * @return
     * true or false depending on equality
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Location location = (Location) o;

        if (latitude != location.latitude) return false;
        if (longitude != location.longitude) return false;
        return name != null ? name.equals(location.name) : location.name == null;
    }

    @Override
    public int hashCode() {
        int result;
        long temp;
        temp = Double.doubleToLongBits(latitude);
        result = (int) (temp ^ (temp >>> 32));
        temp = Double.doubleToLongBits(longitude);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        result = 31 * result + (name != null ? name.hashCode() : 0);
        result = 31 * result + (isFavourite ? 1 : 0);
        result = 31 * result + (path != null ? path.hashCode() : 0);
        return result;
    }

    @Override
    public String toString() {
        return getName();
    }

}


